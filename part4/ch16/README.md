# 전역 메서드 보안: 사전 및 사후 권한 부여

스프링 시큐리티는 웹 애플리케이션과 웹이 아닌 애플리케이션의 권한 부여를 구성할 수 있고 이를 전역 메서드 보안이라고 한다.

```
엔드포인트 -> 서비스 -> 리포지토리

전역 메서드 보안을 사용하면 애플리케이션 모든 계층에 권한 부여 규칙을 적용할 수 있다. 또한 **엔드포인트 없이**도 권한 
부여 규칙을 구현할 수 있게 해준다.
```
## 전역 메서드 보안 활성화
```
전역 메서드는 기본적으로 비활성 상태이기 때문에 기능을 사용하려면 활성화 해야며 전역 메서드 보안으로 할 수 있는일은 크게 2 가지다.

* 호출 권한 부여
* 필터링
```
### 호출 권한 부여의 이해 
```
전역 메서드 보안을 활성화 하면 스프링 애스펙트가 적용된다. 애스펙트는 메서드 호출 전, 후 요청을 가로채고 권한 부여 규칙(어드바이스) 이 
충족되지 않으면 호출을 전달하지 않고 예외를 투척한다!  

  사전 권한 부여: 메서드 호출 전 애스펙트에서 어드바이스로 권한을 검사하고 충족되지 않으면 호출하지 않고 예외를 던진다.
  
  사후 권한 부여: 메서드는 호출됐지만 결과를 반환할 때 애스펙트가 결과를 가로채고 권한 부여 규칙을 검사한다. 마찬가지로 
  규칙을 준수하지 않으면 예외를 던진다.

사후 권한 부여 어드바이스를 구현할 때 **주의** 할 점은 트랜잭션이 적용되지 않는 다는 것이다. 즉 호출 메서드는 성공해서 데이터베이스에 
값이 저장됐는데 사후 권한 부여 규칙을 준수하지 못해서 예외가 투척될 수 있다. (커밋 후 예외 발생)
```
### 프로젝트에서 전역 메서드 보안 활성화 하기! 
```
* 전역 메서드 보안 규칙을 정의하는 3 가지 방법

사전/사후 권한 부여 애노테이션 지정(@EnableGolbalMethodSecurity)
JSR 250 애노테이션(@RolesAllowed)
@Secured 애노테이션

보통 거의 모든 상황에서 사전/사후 권한 부여 애노테이션을 사용함
```
### 권한과 역할에 사전 권한 부여 적용하기
```
메서드 매개 변수의 값으로 권한 부여 규칙을 정의하기, 파라미터로 넘어오는 값에 따라 사전에 권한을 확인하고 호출 여부를 
결정하는 유스케이스를 만들어 본다.

컨트롤러에서 NameService 를 이용해 사용자의 비밀 이름 목록을 얻을 때 보안 애스펙트의 어드바이스는 매개 변수로 제공된
이름이 인증된 사용자의 이름을 저장하는 NameService 에 있는지 확인하고

인증된 사용자 이름이 일치하는 항목이 없으면 애스펙트는 서비스 클래스를 호출하지 않고 예외를 투척한다.

* ex 16, ex 1 (config, controlle, service 유스 케이스 참고) 

@PreAuthorize("#name == authentication.principal.username") 
public List<String> getSecretNames(String name)

메서드 매개변수의 값을 나타내려면 (#매개변수 이름) 으로 나타낸다. 서비스 계층의 메서드 레벨로 사전 권한 부여를 적용했다.
이 애노테이션이 애스펙트 프록시의 어드바이스가 되고 스프링 AOP 로 작동한다. 

참고로 전역 메서드 보안은 애플리케이션의 어떤 계층에도 적용할 수 있다. 리포지토리, 매니저 프락시 등 어떤 부분에도
전역 메서드 보안으로 권한 부여 적용이 가능하다.
```
### 사후 권한 부여 적용하기
```
메서드의 호출은 허용하지만 조건을 충족하지 못하면 호출자가 반환될 값을 받지 못하게 해보자! 
(메서드까지는 호출되고 후에 권한 부여 규칙을 적용함)

메서드 호출은 허용하지만 결과를 얻지 못하게 하는 이유는 메서드를 호출하는 상대에 관해서 확신할 수 없기 때문이다. 448 p 
메서드의 실행은 허용하되 반환되는 내용을 검증하고 **기준** 이 충족되지 않는다면 호출자가 반환값에 접근하지 못하게 하는것.
```
```
* 사후 권한 부여 시나리오 구현 ex 16 ex 2 참고

직원이 읽은 책의 세부 정보를 호출하는 엔드포인트를 만들고 서비스에서 직원 정보의 값을 리턴할 때 역할에 따라서
세부 정보를 얻을 수 있는 직원과 그렇지 않은 직원을 만들었다 (reader, researcher)

그리고 사후 권한 부여를 메서드 레벨로 만들고 @PostAuthorize("returnObject.roles.contains('reader')")
(returnObject 는 메서드의 리턴값을 의미함) 

reader (읽을 수있음) 역할이 있는 직원의 세부 정보만 볼 수 있도록 SpEL 식을 만들었음.
```
## 메서드의 사용 권한 구현하기

지금까지는 간단하게 사후,사전 권한 부여를 위한 규칙을 정의했다, 권한 부여 논리가 복잡해지면 간단한 SpEL 식으로는

해결할 수 없는 경우가 생긴다. (긴 SpEL 식은 권장 하지 않는다. 복잡하고 유지 보수성을 떨어뜨림)

복잡한 권한 부여 규칙을 만들어야 하면 별도의 클래스로 만들어야 한다. 

### 간단한 문서 관리 애플리케이션으로 사용 권한 구현하기 
```
* ex 16 ex 3 참고 

문서를 관리하는 간단한 애플리케이션을 만든다. 모든 문서에는 해당 문서를 작성한 사용자인 소유자가 있다. 
기존 문서의 세부 정보를 얻기 위해서는 사용자의 역할이 관리자이거나, 해당 문서의 소유자 이여야 한다.
```
```
* PermissionEvaluator 구현하기 DocumentService, DocumentPermissionEvaluator 참고

@PostAuthorize("hasPermission(returnObject, 'ROLE_admin')") 사용권한 논리 hasPermission 을 사용하려면
PermissionEvaluator 계약을 직접 구현해야 한다.

사용 권한 평가기 클래스에 역할의 이름을 직접 구현하면(하드 코딩) 파라미터로 값을 넘겨주지 않아도 된다. 

참고로 사용 권한 평가기를 생성할 때 Authorization 인증 객체도 필요한데 이 값은 hasPermission() 메서드를 호출할 때
스프링 부트가 자동으로 SecurityContext 에서 값을 제공해 준다.

PermissionEvaluator 를 구현하면 구현을 인식할 수 있도록 구성 클래스에 정의해야 한다.
ex 16 ex 3 config 참고 
```
```
* PermissionEvaluator 의 두 번째 메서드를 사용하기 DocumentPermissionEvaluator 참고

두 번째 메서드는 객체 자체가 아닌 ID 와 주체 형식을 이용한다. 
@PostAuthorize("hasPermission(#code, 'document', 'ROLE_admin')")
```

## @Secured 및 @RolesAllowed 애노테이션 사용하기

이 단원에서는 전체 전역 메서드 보안으로 권한 부여 규칙을 적용하는 방법을 실습했다. 

이 기능은 기본적으로 비활성화 되며 구성 클래스에서 @EnableGlobalMethodSecurity 애노테이션으로 활성화 해서 사용한다.

```
* @EnableGlobalMethodSecurity 애노테이션 알아보기

이 애노테이션은 권한 부여 규칙을 특정화 해서 사용할 수 있다.


@EnableGlobalMethodSecurity(prePostEnabled = true) 
-> prePostEnabled 특성은 @PreAuthorize, @PostAuthorize 애노테이션으로 권한 부여 규칙을 지정할 수 있게 해준다.

@EnableGlobalMethodSecurity(jsr250Enabled = true, securedEnabled = true)
-> 이 두 가지 규칙은 각각 @Secured, @RolesAllowed 애노테이션을 활성화 한다, 이 두가지 애노테이션은 기능이 빈약해서
잘 사용하지는 않는다.

@Secured("ROLE_ADMIN"), @RolesAllowed("ROLE_ADMIN") 메서드 레벨에서 역할이나 권한이 있는 경우에 특정 메서드를 
호출할 수 있게 해주는 기능을 제공한다.
```
