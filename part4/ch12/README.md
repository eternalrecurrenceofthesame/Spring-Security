# OAuth 2 가 작동하는 방법

## OAuth 2 프레임워크

OAuth 2 는 권한 부여 프레임워크라고 불리며 타사 웹 사이트나 웹 리소스에 접근할 수 있게 허용하는 것이 주 목적이다. 

OAuth2 는 특정 구현이나 라이브러리가 아니다. OAuth 2 는 흐름 정의와 함께 다른 플랫폼, 도구, 언어를 적용할 수도 있다 321 p

스프링 시큐리 OAuth 2 를 구현할 수 있다. 

```
모든 요청에 대해 자격증명을 보내는 방식인 Http.Basic() 은 네트워크를 통해 자격 증명이 자주 공유되고 
클라이언트(웹 애플리케이션의 경우 브라우저, 웹 애플리케이션을 의미함) 가 자격 증명을 저장하고 있기 때문에 보안에 취약하다!

대부분의 경우 별도의 시스템에서 자격 증명을 관리하는 것이 바람직하다. (ch11 에서 만든 것 처럼)
```

### OAuth 2 인증 아키텍처의 구성 요소
```
* 구성 요소

리소스 서버: 사용자가 소유한 리소스를 호스팅(임대해주는)하는 서버, 리소스(사용자가 소유한 데이터, 사용자가 수행할 작업)

사용자(또는 리소스 소유자): 리소스 서버가 노출하는 리소스를 소유하는 개인, 일반적으로 사용자는 사용자 이름과 암호로 인증한다.

클라이언트: 사용자를 대신해 사용자가 소유한 리소스에 접근하는 애플리케이션. 클라이언트는 클라이언트 ID 와 클라이언트 비밀을 이용해
신원을 증명한다. 이러한 자격증명은 사용자 자격 증명과 다르며 클라이언트는 요청할 때 자신을 증명하는 전체 자격 증명이 필요하다

권한 부여 서버: 클라이언트가 리소스 서버가 노출하는 사용자의 리소스에 접근할 권한을 부여하는 애플리케이션, 권한 부여 서버는 
클라이언트가 사용자 대신 리소스에 접근 권한이 있다고 결정하면 토큰을 발급한다. 

클라이언트는 이 토큰을 이용해 권한 부여 서버에서 권한을 받았음을 리소스 서버에 증명한다. 리소스 서버는 유효한 토큰이 있으면
클라이언트가 요청한 리소스에 접근하게 허용한다.
```
```
* 구성 요소 간 '통신' 방식

사용자는 사용자가 소유한 리소스에 접근할 때 클라이언트에 접근을 요청 한다. 사용자는 권한 부여서버에 사용자 인증을 하면서
클라이언트가 리소스에 접근할 수 있도록 허락했다는 것을 알려줘야 한다.

(클라이언트는 애플리케이션으로 웹 앱이거나 모바일 앱일 수 있다. 이 애플리케이션을 통해서 리소스에 접근한다.)

클라이언트는 권한 부여 서버에서 권한을 승인 받고 리소스 서버에 접근할 수 있다. 클라이언트는 권한 부여 서버에서 받은 토큰을 이용해서
리소스 서버에 접근한다.

리소스 서버는 사용자가 소유한 데이터를 유지하고, 사용자가 승인한 클라이언트(애플리케이션)만 리소스를 이용하도록 허용한다.
리소스를 이용하려는 클라이언트는 권한 부여 서버에서 받은 토큰으로 권한을 증명해야 한다.

클라이언트(웹 애플리케이션), 권한 부여 서버(애플리케이션), 리소스 서버(리소스 데이터를 저장) 는 각각의 애플리케이션으로 운영된다.
324p
```

## OAuth 2 를 구현하는 방법 선택하기

OAuth 2 는 그랜트라고 하는 토큰을 얻는 여러 방법을 제공한다. 예제에서는 가장 일반적인 사례를 적용한다! 

그랜트는 토큰을 얻기 위한 흐름이다! 

### 승인 코드 그랜트 유형의 구현

이 유형은 가장 많이 이용되는 OAuth 2 흐름이다.

* 1 단계: 승인 코드 그랜트 유형으로 인증 요청 수행
```
사용자가 리소스에 접근을 시도하면 클라이언트는 사용자가 인증(로그인) 해야 하는 권한 부여 서버의 엔드포인트로 사용자를 리디렉션한다.
사용자 인증에 성공하면 권한 부여 서버는 클라이언트를 호출하면서 **사용자 인증 요청에 대한 코드와 상태 값**을 제공한다. 

클라이언트는 상태 값이 요청에서 보낸 것과 같은지 검사해 다른 사람이 리디렉션 URI 를 호출하려는 것이 아닌지 확인한다. 327 p
클라이언트는 권한 부여 서버가 제공하는 승인 코드를 이용해서 2 단계 액세스 토큰을 얻을 수 있다.

이 단계에서 알아둬야 할 것은 사용자가 권한 부여 서버와 직접 상호작용해서 클라이언트 앱으로 자격 증명을 보내는 것이 아니라는 것이다.
(사용자가 직접 권한 부여 서버에 인증하는 것이고, 클라이언트의 접근을 권한 부여 서버에 요청하는 것이다.)

클라이언트가 사용자를 권한 부여 서버로 리디렉션할 때 클라이언트는 다음 세부 정보가 포함된 요청 쿼리로 권한 부여 엔드포인트를 호출한다.
```
```
# response_type: 액세스 토큰을 때 사용하는 코드

# clident_id: 클라이언트 애플리케이션을 식별하는 id 값 
# redirect_uri: 인증 성공 후 사용자를 리디렉션할 위치를 권한 부여 서버에 알려준다. 권한 부여 서버가 클라이언트 기본 리디렉션 URI 를
이미 알고 있다면 보낼필요 없다.

# scope: 5 장에서 알아본 허가된 권한과 비슷하다.
# state: 10 장에서 알아본 CSRF 보호를 위한 토큰을 정의한다.
```

* 2 단계: 승인 코드 그랜트 유형으로 액세스 토큰 얻기
```
1 단계에서 생성된 코드는 사용자가 리소스에 접근할 수 있도록 사용자가 인증했다는 클라이언트 증명이 된다.
(사용자가 선택한 클라이언트가 리소스에 접근할 수 있도록 허용했다는 것임)

이것을 승인 코드 그랜트 유형이라고 부르는 이유다. 승인 코드로 그랜트를 받는다!

클라이언트는 리소스 접근 토큰을 얻기 위해 승인 코드로 권한 부여 서버를 호출한다. 
(2 단계부터는 클라이언트와 권한 부여 서버 간에 상호 작용이 수행된다.)

승인 코드, 리소스 접근 토큰을 구분해서 분류해야 한다! 승인 코드는 사용자가 권한 부여서버에 인증하고 인증된 사용자가 클라이언트의 접근을 허용했다는 의미이고
리소스 접근 토큰은 클라이언트가 리소스에 접근하기 위해 권한 부여 서버로부터 얻은 토큰이다.

권한 부여 서버가 2 단계에 걸쳐 리소스 접근 토큰을 반환하는 이유는 사용자가 요청한 클라이언트에 토큰을 반환하기 위함이다. 

클라이언트는 액세스 토큰을 얻기 위해 사용자의 허가를 입증하는 승인 코드를 제시하고 자신이 승인 코드를 가로챈 다른 사람이 아니며
실제로 같은 클라이언트임을 증명하는 자격 증명을 제시하고 호출한다.

클라이언트가 권한 부여 서버에 요청할 때 필요한 세부 정보
```
```
# code: 1 단계에서 받은 승인 코드, 사용자 인증을 받았음을 증명한다.
# client_id 및 client_secret: 클라이언트의 자격 증명

# redirect_uri: 1 단계에서 검증에 사용된 것과 같다.
# grant_type: 이용된 흐름의 유형을 식별하며 authorization_code 값을 가진다. 서버가 여러 흐름을 지원할 수 있으므로
항상 실행된인증흐름이 무엇인지 지정하는 것이 필수적이다.
```

* 3 단계: 승인 코드 그랜트 유형으로 보호된 리소스 호출
```
권한 부여 서버로부터 액세스 토큰을 받으면 클라이언트는 헤더 값에 액세스 토큰을 포함시킨 요청으로 엔드포인트에 접근할 수 있다.

승인 코드 그랜트 유형은 자신의 자격 증명을 클라이언트와 공유하지 않고 클라이언트가 특정 작업을 실행하도록 허가할 수 있다는
이점이 있지만 약점도 있다.

누군가 리소스 접근 토큰을 얻기 위한 승인 코드를 가로채고 클라이언트 자격 증명이 유출된다면? 승인 코드만으로 리소스 접근 토큰을
얻을 수 없고, 클라이언트  자격 증명까지 유출될 가능성은 낮지만 이 시나리오는 고려해볼 가치가 있다. 

이 취약성을 완화하려면 PKCE 승인 코드 그랜트 유형을 이용하는 더 복잡한 시나리오에 의존해야 한다.
tools.ietf.org/html/rfc7636 참고 
```

### 암호 그랜트 유형 구현
```
이 그랜트 유형을 리소스 소유자 자격 증명 그랜트 유형이라고도 한다. 11 장에서 만든 토이 프로젝트 구성과 비슷한 유형
이 유형은 클라이언트와 권한 부여 서버를 같은 조직에서 구축하고 유지 관리할 때만 이용한다.

마이크로서비스에서 인증 책임을 분리하는 경우, 프런트 엔드 프레임워크로 개발된 클라이언트 웹 애플리케이션이나
모바일 앱에서 인증해야 하는 경우 사용한다 331 p
```
* 1 단계: 암호 그랜트 유형으로 액세스 토큰 요청
```
클라이언트는 사용자 자격 증명을 수집하고, 권한 부여 서버를 호출해 액세스 토큰을 얻는다. 클라이언트는
액세스 토큰을 요청할 때 다음의 세부 정보를 함께 보낸다.

grant_type: password 값을 가진다.
client_id 및 client_secret: 클라이언트가 자신을 인증하기 위한 자격 증명.

scpoe: 허가된 권한
useranme 및 password: 사용자 자격 증명, 요청의 헤더 값으로 전송, 일반 텍스트 형식
```

* 2 단계: 암호 그랜트 유형으로 액세스 토큰을 이용해 리소스 호출하기
```
클라이언트는 1 단계의 응답으로 액세스 토큰을 받는다. 클라이언트는 액세스 토큰을 애플리케이션 헤더에 추가해서
리소스를 호출할 수 있다.

암호 그랜트 유형은 사용자 자격 증명을 클라이언트 앱과 공유한다고 가정하기 때문에 승인 코드 부여 유형보다 
덜 안전하다. 보통 이론적인 예에서 많이 사용하며, 실제 시나리오에서는 이 그랜트 유형을 피하는 것이 좋다.

권한 부여 서버와 클라이언트를 같은 조직으로 구축했어도 승인 코드 그랜트 유형을 먼저 고려하자!
```
### 클라이언트 자격 증명 그랜트 유형 구현

OAuth 2 가 지원하는 가장 단순한 그랜트 유형 사용자가 관여하지 않고 두 애플리케이션 간의 인증을 구현할 때

이용할 수 있다.

* 1 단계: 클라이언트 자격 증명 그랜트 유형으로 액세스 토큰 얻기
```
클라이언트는 액세스 토큰을 얻기 위해 다음 세부 정보와 함께 권한 부여 서버에 요청을 보낸다.

grant_type: client_credentials 값을 가진다.
client_id 및 client_secret: 클라이언트 자격 증명을 나타낸다.
scope: 허가된 권한을 나타낸다.

클라이언트는 응답으로 권한 부여 서버로부터 액세스 토큰을 받는다.
```
* 2 단계: 클라이언트 자격 증명 그랜트 유형으로 액세스 토큰을 이용해 리소스 호출
```
앞서 받은 액세스 토큰을 사용해서 리소스를 호출한다. 
(승인 코드 그랜트 유형, 암호 그랜트 유형과 마찬가지로 권한 부여 요청 헤더에 액세스 토큰 추가)
```

### 갱신 토큰으로 새 액세스 토큰 얻기

OAuth 2 의 그랜트(리소스 접근, 액세스 토큰) 는 최소한의 수명을 가지게 만들어야 한다. 334p

갱신 토큰은 새 액세스 토큰을 얻기 위해 자격 증명을 하는 방법의 대안이다. (13 장에서 구현 예정)

```
이용된 그랜트 유형에 따라 액세스 토큰을 얻기 위해 흐름을 다시 실행할 수도 있다. 이때 그랜트 유형에서 사용자 인증을 요구하고, 
액세스 토큰의 만료 시간이 20 분 정도라면

사용자는 20 분 마다 사용자 인증을 해야한다. 
**(이런 일련의 과정을 없애기 위해 클라이언트에 사용자 인증정보를 저장하게 하면 안 된다!! 335p)**

이때 사용할 수 있는 것이 갱신 토큰이다. 권한 부여 서버는 재인증할 필요를 없애기 위해 액세스 토큰과 
용도가 같은 다른 갱신 토큰을 발행할 수 있고 애플리케이션은 재인증 없이 새 액세스 토큰을 얻을 수 있다.

갱신 토큰은 노출된 것이 확인되면 취소할 수 있으므로 안전하다! 
```
```
* 갱신 토큰을 이용하는 방법 

권한 부여 서버는 승인 코드나 암호 그랜트 유형과 같은 흐름을 사용할 때 액세스 토큰과 함께 갱신 토큰을 반환한다.
클라이언트 자격 증명 그랜트 유형에는 사용자 자격 증명이 필요 없으므로 갱신 토큰도 사용되지 않는다. 336p

갱신 토큰을 가진 클라이언트는 액세스 토큰이 만료될 때 다음 세부 정보가 포함된 요청을 발행한다.

- refresh_token 값을 가지는 grant_type
- 갱신 토큰의 값을 가지는 refrech_token

- 클라이언트의 자격 증명을 포함하는 client_id 와 client_secret 
- 같거나 더 작은 허가 권한을 정의하는 scope 더 많은 허가 권한을 부여해야 할 때는 재인증이 필요하다.

이 요청에 대한 응답으로 권한 부여 서버는 새 액세스 토큰과 새 갱신 토큰을 발행한다. 336 p 
```
### OAuth 2 의 허점
```
클라이언트에서 CSRF 이용 - CSRF 메커니즘을 적용하지 않으면 사용자가 로그인했을 때 CSRF 가 가능하다. 
CSRF 대신 JWT 토큰을 사용할 수도 있다. ch10, ch11

클라이언트 자격 증명 도용 - 보호되지 않는 자격 증명을 저장하거나 전송하면 이를 공격자가 도용하는 위반이 
발생할 수 있다.

토큰 재생 - 토큰을 가로채면 누군가 토큰을 재사용할 수 있다. (토큰 재생은 14 장에서 더 자세히 알아본다)

토큰 하이재킹 - 인증 프로세스를 방해하고 리소스에 액세스 하기 위한 토큰을 하이잭 하는 것을 의미한다.
토큰이나 갱신 토큰을 가로채면 누군가 재사용할 수 있다 337p

blog.intothesymmetry.com/2015/06/on-oauth-token-hijacks-for-fun-and.html 참고 
```

## 깃허브 인증을 사용해서 간단한 SSO 애플리케이션 로그인 구현하기

Single Sign On 이란 사용자가 권한부여서버에서 인증하고 애플리케이션이 토큰으로 로그인 상태를 유지하는 것을

의미한다. (한마디로 승인 그랜트 유형이네) 337 p 
```
승인코드 그랜트유형을 깃허브 인증으로하는 간단한 LoginIn 을 구현해본다. OAuth 2 로그인에 관한 자세한 내용은 아래 
링크를 참고한다. 
(아래 내용을 바탕으로 애플리케이션을 구현한다. 부족한 내용은 참고) 

https://github.com/eternalrecurrenceofthesame/Spring-security-in-action/tree/main/part4/OAuth2-spring-security/OAuth2-login
```
```
* 외부 인증 개념에 대해서

한가지 주의할 개념은 깃허브나 다른 외부 인증을 사용한다고 해서 인증서버를 직접 구현하는 것이 아니다. 인증서버를 구현하는
방식에는 키클록 같은 인증서버를 사용하거나 직접 인증서버를 시큐리티 코드로 구현하는 방법이 있다.

외부 인증 시스템으로써 시큐리티가 제공하는 CommonOAuth2Provider(구글,깃헙,페이스북,옥타) 를 사용하면 인증에 필요한 토큰을 
쉽게 받을 수 있지만 이것만으로는 스프링 시큐리티 권한 부여 서버를 구현한다고 할 수 없다. 

여기서는 간단하게 외부 시스템으로부터 토큰을 받고 로그인에 이용하는 방법을 구현한다. 

권한부여 서버와 리소스 서버의 구현, 키클록을 이용한 권한부여 서버에 관한 것은 아래 내용들을 참고한다. 
https://github.com/eternalrecurrenceofthesame/Spring-security-in-action/tree/main/part4/OAuth2-spring-security/OAuth2-authentication
https://github.com/eternalrecurrenceofthesame/Spring-security-in-action/tree/main/part4/OAuth2-spring-security/OAuth2-resource
https://github.com/eternalrecurrenceofthesame/Spring-security-in-action/tree/main/part4/ch18
```
### 외부 인증서버 관리(깃 허브)
```
* 시나리오

https://github.com/settings/applications/new 에서 깃허브 인증 서버를 구현한다
간단하게 애플리케이션 이름과 URL, 콜백 URL 을 설정한다.

사용자가 localhost:8080 리소스를 호출한다. 인증 서버는 웹 애플리케이션을 사용자 인증 페이지로 리다이렉트한다.
사용자가 인증에 성공하면 

권한 부여 서버는 권한 부여 서버에 정의된 콜백 URL(localhost:8080) 로 클라이언트(브라우저) 를 다시 호출한다.  

Tip
권한 부여 서버를 외부로 노출하지 말아야 한다! 이런 자격 증명으로 기밀 정보에 접근할 수 있다!
또한 자격 증명을 깃 허브 같은  공개된 리포지토리에 저장할 때는 주의 해야한다. 
```
### SSO 애플리케이션 구현 시작
```
* controller 
```
```
* config

http.basic 이나 http.fromLogin() 과 마찬가지로 http.ouath2Login() 을 사용하면 필터 체인에 OAuth2LoginAuthenticationFilter 
를 추가한다. 이 필터는 요청을 가로채고 OAuth 2 인증에 필요한 논리를 적용한다. 342 p 

OAuth2LoginAuthenticationFiler 는 ClientRegistrationRepository 에서 등록된 인증 서버에 관한 세부 정보를 얻는다.


참고로 권한 부여 서버를 직접 구현하고 인증 클라이언트 유형을 등록하는 경우 RegisteredClientRepository 를 사용한다. 아래 예제 참고
https://github.com/eternalrecurrenceofthesame/Spring-security-in-action/tree/main/part4/OAuth2-spring-security/OAuth2-authentication
https://github.com/eternalrecurrenceofthesame/Spring-MSA/tree/main/part02/ch11

즉 ClientRegistrationRepository 와 RegisteredClientRepository 는 다른 개념이다. 아래 내용을 참고한다.
https://docs.spring.io/spring-authorization-server/docs/current/reference/html/core-model-components.html
```
#### + OAuth2LoginAuthenticationFilter 에 대해서
```
이 필터는 앞서 설명했듯이 oath2Login 을 사용하면 적용되는 필터이다. 이 필터는 ClientRegistrationRepository
에 등록된 외부 인증 서버에 관한 세부 정보를 사용한다.

이 필터는 승인 코드 그랜트 유형에서 사용자가 권한 부여 서버에서 인증을하고 클라이언트가 승인 코드와 상태정보를 이용해서
권한 부여 서버에서 토큰을 발급 받은 후 리소스를 호출하기 전에 사용된다. 

이 필터는  OAuth2LoginAuthenticationToken 을 생성하고 AuthenticationManager 를 호출하는 역할을 한다.

리소스 서버에서 인증 토큰을 사용하는 과정에대해서는 아래 내용을 참고한다. 
https://github.com/eternalrecurrenceofthesame/Spring-security-in-action/tree/main/part4/OAuth2-spring-security/OAuth2-resource#readme
```

```
* ClientRegistration 구현하기 ProjectConfig 참고

OAuth 2 클라이언트와 인증 서버(깃 허브 서버) 간의 연결을 구현해보자! 깃허브가 애플리케이션의 인증 서버임을 설정하기 위해
ClientRegistration 계약을 정의해야 한다.

ClientRegistration 구현 명세 (필수 명세)

클라이언트 ID 와 비밀
인증에 이용되는 그랜트 유형
리디렉션 RUI
범위

애플리케이션이 인증 프로세스를 진행하려면 이러한 세부 정보가 모두 필요하다! 

권한 부여 서버를 직접 개발하지 않는 경우 OAuth 2 클라이언트와 외부 인증 서버를 연결하기 위한 설명서가 
필요할 수도 있다. (기본적으로 구현해야하는 필수 명세 외의 필요한 정보가 있을수 있음)

깃 허브 권한 부여 서버를 사용하면
developer.github.com/apps/building-oauth-paas/authorizing-oauth-apps 에서 확인 가능하다. 
```
```
* CommonOAuth2Provider 를 정의해서 연결하기 ProjectConfig 참고 

구글, 깃허브, 페이스북, 옥타 같은 일반적인 인증 서버 공급자를 이용하면 Provider 를 이용해서 간편하게 구현할 수 있다.
이런 일반적 공급자가 아니라면 ClientRegistration 을 완전히 정의해야 한다.

Tip
클라이언트 아이디와 클라이언트 비밀은 자격 증명이므로 중요 데이터에 해당한다. 실제 애플리케이션에서는 비밀 볼트에서
이 값을 얻어야 한다. 예제에서 처럼 소스 코드에 바로 자격 증명을 지정해서는 안 된다.
```
### ClientRegistrationRepository 구현하기

권한 부여 서버가 인증에 사용하는 ClientRegistration 인스턴스를 스프링 시큐리티에 등록해보자! 

```
OAuth2LoginAuthenticationFilter 는 ClientRegistrationRepository 를 호출하고 등록된 ClientRegistration
인스턴스를 사용한다.

ClientRegistrationRepository 는 UserDetailsService 인터페이스와 비슷하다. UserDetailsService 가 사용자 
이름으로 유저 정보를 찾은 것 처럼 ClientRegistrationRepository 는 등록 ID 로 ClientRegistration 을 찾는다.

쉽게 말해서 클라이언트에서 연결된 인증 서버(Git hub) 를 찾는 것을 풀어서 설명한 거임

앞서 설명했지만 인증 2 단계에서는 클라이언트와 인증 서버 간 상호작용이 수행됨.

ex 12 singlesignon ProjectConfig 참고 // oauth2Login() 의 매개 변수로 등록할 수도 있다! 메서드 참고 
두 가지 옵션 중 어느 것을 선택해도 상관 없지만 하나를 선택했으면 일관성 있게 애플리케이션에 적용해야한다.
```
```
* 스프링 부트 구성 설정 

스프링 부트는 속성 파일로 ClientRegstration 과 ClientRegistrationRepository 객체를 구축하는 기능을 제공한다 
이 접근법을 자주 사용함.

application.properties

spring.security.oauth2.client.registration.github.client-id=
spring.security.oauth2.client.registration.github.client-secret

클라이언트 아이디와 비밀번호만 설정하면 된다! 이렇게만 해주면 
ClientRegstration 과 ClientRegistrationRepository 를 직접 빈으로 등록하는 것을 대신 해준다!


시큐리티가 제공하는 일반 공급자가 아닌 다른 공급자를 이용할 때는 권한 부여 서버에 관한 세부 정보를 추가해야 한다.
spring.security.oauth2.client.registration.myprovider.client-id=
spring.security.oauth2.client.registration.myprovider.client-secret
+
spring.security.oauth2.client.provider.myprovider.authorization-uri=<some uri>
spring.security.oauth2.client.provider.myprovider.token-uri=<some uri>

인증 공급자가 여러 개일 때는 이처럼 스프링 부트 설정을 이용하면 깔끔하게 유지할 수 있다.

반면 데이터베이스에 세부 정보를 저장하거나(연습 해보기), 웹 서비스에서 이를 얻는 등 다른 기능이 필요하다면
ClientRegistrationRepository 의 맞춤형 구현을 작성하면 된다! 
```

### 인증된 사용자의 세부 정보 얻기
```
스프링 시큐리티에서 인증된 사용자의 세부 정보는 SecurityContext 에 저장된다. 인증 프로세스가 끝나면 담당 필터가
Authentication 객체를 SecurityContext 에 저장한다. 

애플리케이션은 여기에서 사용자 세부 정보를 얻고 필요에 따라 이용할 수 있다 이 프로세스는 OAuth 2 인증에서도 마찬가지다.
OAuth2AuthenticationToken 을 엔드 포인트 매개 변수로 사용하면 스프링 부트가 엔드 포인트에 OAuth 2 인증 객체를 주입해준다
350p

MainController 참고 
```

## 애플리케이션 테스트

애플리케이션에 접근하면 깃 허브에서 사용자 인증을 하고 리디렉션 될 때 깃 허브의 콜백 URL 로 클라이언트를 호출한다!
